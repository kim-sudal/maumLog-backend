from sqlalchemy import text
from .vo import DiaryVO, DiaryCreateRequest, DiaryUpdateRequest
from ..common.encryption_service import EncryptionService
from typing import List, Dict, Any, Tuple, Optional, Union
from datetime import datetime
import traceback

class EmotionDiaryRepository:
    def __init__(self, db):
        self.db = db
        # ÏïîÎ≥µÌò∏Ìôî ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî
        self.enc = EncryptionService()
    
    def create(self, vo: DiaryCreateRequest) -> int:
        """Í∞êÏ†ïÏùºÍ∏∞ ÏÉùÏÑ± (ÏïîÎ≥µÌò∏Ìôî Ï†ÅÏö©)"""
        try:
            sql = text("""
                INSERT INTO tbl_emotion_diary (
                    USER_IDX, 
                    DIARY_CONTENT, 
                    AI_RESPONSE,
                    AI_SELECT, 
                    CONDITION1, CONDITION2, CONDITION3, CONDITION4, CONDITION5, CONDITION6,
                    CONDITION1_RESPONSE, CONDITION2_RESPONSE, CONDITION3_RESPONSE, 
                    CONDITION4_RESPONSE, CONDITION5_RESPONSE,
                    AI_MODEL, RECORD_DATE, REG_DATE, STATUS_CODE
                ) VALUES (
                    :user_idx,
                    fn_enc(:diary_content, :encryption_key),
                    fn_enc(:ai_response, :encryption_key),
                    :ai_select,
                    :condition1, :condition2, :condition3, :condition4, :condition5, :condition6,
                    fn_enc(:condition1_response, :encryption_key),
                    fn_enc(:condition2_response, :encryption_key),
                    fn_enc(:condition3_response, :encryption_key),
                    fn_enc(:condition4_response, :encryption_key),
                    fn_enc(:condition5_response, :encryption_key),
                    :ai_model, :record_date, NOW(), 'Y'
                )
            """)
            
            params = vo.dict()
            
            # üî• Î¨∏Ï†úÏ†ê 1 ÏàòÏ†ï: Ïù¥Ï§ë ÏïîÌò∏ÌôîÏóêÏÑú Îã®Ïùº ÏïîÌò∏ÌôîÎ°ú Î≥ÄÍ≤Ω
            # MySQL fn_enc()Îßå ÏÇ¨Ïö© (DB Î†àÎ≤® ÏïîÌò∏Ìôî)
            
            # ÏùëÎãµÍ∞í Îß§Ìïë (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
            if 'condition4_response' in params:
                params['ai_select'] = params.pop('condition4_response')
            elif 'condition4' in params:
                params['ai_select'] = params.pop('condition4')
            
            if 'condition5_response' in params:
                params['condition4_response'] = params.pop('condition5_response')
            
            if 'condition6_response' in params:
                params['condition5_response'] = params.pop('condition6_response')
            
            # üî• Î¨∏Ï†úÏ†ê 2 ÏàòÏ†ï: ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞Î•º DB Ìï®ÏàòÎ°úÎßå ÏïîÌò∏Ìôî
            params.update({
                'diary_content': params.get('content', ''),  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
                'ai_response': params.get('ai_response', ''),  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
                'encryption_key': self.enc.get_encryption_key()
            })
            
            # Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            if not params.get('record_date'):
                params['record_date'] = datetime.now()
            
            # üî• Î¨∏Ï†úÏ†ê 3 ÏàòÏ†ï: ÏùëÎãµÎì§ÎèÑ ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î°ú Ï†ÑÎã¨
            # Python ÏïîÌò∏Ìôî Ï†úÍ±∞, MySQL Ìï®ÏàòÏóêÏÑúÎßå ÏïîÌò∏Ìôî
            
            # ÎàÑÎùΩÎêú ÌïÑÎìúÎì§ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            params.setdefault('condition1', None)
            params.setdefault('condition2', None)
            params.setdefault('condition3', None)
            params.setdefault('condition4', None)
            params.setdefault('condition5', None)
            params.setdefault('condition6', None)
            params.setdefault('condition1_response', None)
            params.setdefault('condition2_response', None)
            params.setdefault('condition3_response', None)
            params.setdefault('condition4_response', None)
            params.setdefault('condition5_response', None)
            params.setdefault('ai_model', None)
            
            result = self.db.execute(sql, params)
            self.db.commit()
            
            print(f"‚úÖ ÏïîÌò∏ÌôîÎêú Í∞êÏ†ïÏùºÍ∏∞ Ï†ÄÏû• ÏôÑÎ£å (ID: {result.lastrowid})")
            return result.lastrowid
            
        except Exception as e:
            print(f"‚ùå ÏïîÌò∏ÌôîÎêú Í∞êÏ†ïÏùºÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•ò: {str(e)}")
            traceback.print_exc()
            self.db.rollback()
            raise
    
    def get(self, diary_idx: int) -> Optional[dict]:
        """ÏùºÍ∏∞ Ï°∞Ìöå (Î≥µÌò∏Ìôî Ï†ÅÏö©)"""
        try:
            sql = text("""
                SELECT 
                    DIARY_IDX, USER_IDX,
                    fn_dec(DIARY_CONTENT, :encryption_key) as DIARY_CONTENT,
                    fn_dec(AI_RESPONSE, :encryption_key) as AI_RESPONSE,
                    AI_SELECT,
                    CONDITION1, CONDITION2, CONDITION3, CONDITION4, CONDITION5, CONDITION6,
                    fn_dec(CONDITION1_RESPONSE, :encryption_key) as CONDITION1_RESPONSE,
                    fn_dec(CONDITION2_RESPONSE, :encryption_key) as CONDITION2_RESPONSE,
                    fn_dec(CONDITION3_RESPONSE, :encryption_key) as CONDITION3_RESPONSE,
                    fn_dec(CONDITION4_RESPONSE, :encryption_key) as CONDITION4_RESPONSE,
                    fn_dec(CONDITION5_RESPONSE, :encryption_key) as CONDITION5_RESPONSE,
                    AI_MODEL, STATUS_CODE, REG_DATE, UPDATE_DATE, RECORD_DATE
                FROM tbl_emotion_diary 
                WHERE DIARY_IDX = :diary_idx AND STATUS_CODE = 'Y'
            """)
            
            params = {
                'diary_idx': diary_idx,
                'encryption_key': self.enc.get_encryption_key()
            }
            
            result = self.db.execute(sql, params).fetchone()
            
            if result:
                # üî• Î¨∏Ï†úÏ†ê 4 ÏàòÏ†ï: Ïù¥Ï§ë Î≥µÌò∏Ìôî Ï†úÍ±∞
                # MySQL fn_dec()ÏóêÏÑú Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎêú Îç∞Ïù¥ÌÑ∞Ïù¥ÎØÄÎ°ú Ï∂îÍ∞Ä Î≥µÌò∏Ìôî Î∂àÌïÑÏöî
                
                return {
                    "diary_idx": result.DIARY_IDX,
                    "user_idx": result.USER_IDX,
                    "content": result.DIARY_CONTENT or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎêú Îç∞Ïù¥ÌÑ∞
                    "condition1": result.CONDITION1,
                    "condition2": result.CONDITION2,
                    "condition3": result.CONDITION3,
                    "condition4": result.CONDITION4,
                    "condition5": result.CONDITION5,
                    "condition6": result.CONDITION6,
                    "ai_select": result.AI_SELECT,
                    "condition1_response": result.CONDITION1_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    "condition2_response": result.CONDITION2_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    "condition3_response": result.CONDITION3_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    "condition4_response": result.AI_SELECT,  # Í∏∞Ï°¥ Îß§Ìïë Ïú†ÏßÄ
                    "condition5_response": result.CONDITION4_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    "condition6_response": result.CONDITION5_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    "ai_response": result.AI_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎêú Îç∞Ïù¥ÌÑ∞
                    "ai_model": result.AI_MODEL,
                    "status_code": result.STATUS_CODE,
                    "reg_date": result.REG_DATE,
                    "update_date": result.UPDATE_DATE,
                    "record_date": result.RECORD_DATE
                }
            return None
            
        except Exception as e:
            print(f"‚ùå ÏïîÌò∏ÌôîÎêú Í∞êÏ†ïÏùºÍ∏∞ Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")
            traceback.print_exc()
            raise
    
    def get_list(self, user_idx: int = None, start_date: str = None, page: int = 1, page_size: int = 10) -> Tuple[List[dict], int]:
        """ÏùºÍ∏∞ Î™©Î°ù Ï°∞Ìöå (Î≥µÌò∏Ìôî Ï†ÅÏö©)"""
        try:
            # Í∏∞Î≥∏ WHERE Ï°∞Í±¥
            where_conditions = ["STATUS_CODE = 'Y'"]
            params = {'encryption_key': self.enc.get_encryption_key()}
            
            # ÏÇ¨Ïö©Ïûê ÌïÑÌÑ∞
            if user_idx:
                where_conditions.append("USER_IDX = :user_idx")
                params["user_idx"] = user_idx
            
            # ÏõîÎ≥Ñ ÌïÑÌÑ∞ Ï∂îÍ∞Ä
            if start_date:
                where_conditions.append("DATE_FORMAT(RECORD_DATE, '%Y-%m') = :start_date")
                params["start_date"] = start_date
                        
            where_clause = " AND ".join(where_conditions)
            
            # Ï†ÑÏ≤¥ Í∞úÏàò Ï°∞Ìöå
            count_sql = text(f"SELECT COUNT(*) as total FROM tbl_emotion_diary WHERE {where_clause}")
            count_result = self.db.execute(count_sql, {k: v for k, v in params.items() if k != 'encryption_key'}).fetchone()
            total_count = count_result.total if count_result else 0
            
            # Î™©Î°ù Ï°∞Ìöå (ÌéòÏù¥Ïßï)
            offset = (page - 1) * page_size
            params.update({"limit": page_size, "offset": offset})
            
            list_sql = text(f"""
                SELECT 
                    DIARY_IDX, USER_IDX,
                    fn_dec(DIARY_CONTENT, :encryption_key) as DIARY_CONTENT,
                    fn_dec(AI_RESPONSE, :encryption_key) as AI_RESPONSE,
                    CONDITION1, CONDITION2, CONDITION3, CONDITION4, CONDITION5, CONDITION6,
                    fn_dec(CONDITION1_RESPONSE, :encryption_key) as CONDITION1_RESPONSE,
                    fn_dec(CONDITION2_RESPONSE, :encryption_key) as CONDITION2_RESPONSE,
                    fn_dec(CONDITION3_RESPONSE, :encryption_key) as CONDITION3_RESPONSE,
                    fn_dec(CONDITION4_RESPONSE, :encryption_key) as CONDITION4_RESPONSE,
                    fn_dec(CONDITION5_RESPONSE, :encryption_key) as CONDITION5_RESPONSE,
                    AI_SELECT, AI_MODEL, RECORD_DATE, UPDATE_DATE, STATUS_CODE
                FROM tbl_emotion_diary 
                WHERE {where_clause}
                ORDER BY RECORD_DATE DESC, DIARY_IDX DESC
                LIMIT :limit OFFSET :offset
            """)
            
            result = self.db.execute(list_sql, params).fetchall()
            
            # üî• Î¨∏Ï†úÏ†ê 5 ÏàòÏ†ï: Ïù¥Ï§ë Î≥µÌò∏Ìôî Ï†úÍ±∞
            diaries = []
            for row in result:
                diary = {
                    'diary_idx': row.DIARY_IDX,
                    'user_idx': row.USER_IDX,
                    'content': row.DIARY_CONTENT or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'ai_response': row.AI_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'condition1': row.CONDITION1,
                    'condition1_response': row.CONDITION1_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'condition2': row.CONDITION2,
                    'condition2_response': row.CONDITION2_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'condition3': row.CONDITION3,
                    'condition3_response': row.CONDITION3_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'condition4': row.CONDITION4,
                    'condition4_response': row.AI_SELECT,  # Í∏∞Ï°¥ Îß§Ìïë Ïú†ÏßÄ
                    'condition5': row.CONDITION5,
                    'condition5_response': row.CONDITION4_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'condition6': row.CONDITION6,
                    'condition6_response': row.CONDITION5_RESPONSE or "",  # Ïù¥ÎØ∏ Î≥µÌò∏ÌôîÎê®
                    'ai_model': row.AI_MODEL,
                    'record_date': row.RECORD_DATE.isoformat() if row.RECORD_DATE else None,
                    'update_date': row.UPDATE_DATE.isoformat() if row.UPDATE_DATE else None,
                    'status_code': row.STATUS_CODE
                }
                diaries.append(diary)
            
            print(f"‚úÖ ÏïîÌò∏ÌôîÎêú ÏùºÍ∏∞ Î™©Î°ù Ï°∞Ìöå ÏôÑÎ£å ({len(diaries)}Í±¥)")
            return diaries, total_count
            
        except Exception as e:
            print(f"‚ùå ÏïîÌò∏ÌôîÎêú ÏùºÍ∏∞ Î™©Î°ù Ï°∞Ìöå Ï§ë Ïò§Î•ò: {str(e)}")
            traceback.print_exc()
            return [], 0
 
    def update(self, diary_idx: int, vo: DiaryUpdateRequest) -> bool:
        """Í∞êÏ†ïÏùºÍ∏∞ ÏàòÏ†ï (ÏïîÎ≥µÌò∏Ìôî Ï†ÅÏö©)"""
        try:
            # Ï°¥Ïû¨ÌïòÎäî ÏùºÍ∏∞Ïù∏ÏßÄ ÌôïÏù∏
            existing = self.get(diary_idx)
            if not existing:
                return False
            
            # ÎèôÏ†Å ÏøºÎ¶¨ ÏÉùÏÑ±
            update_fields = []
            params = {
                "diary_idx": diary_idx, 
                "encryption_key": self.enc.get_encryption_key()
            }
            
            vo_dict = vo.dict(exclude_unset=True, exclude={'diary_idx'})
            
            # üî• ÏàòÏ†ï 1: ÎÇ¥Ïö© ÏàòÏ†ï Ïãú Îã®Ïùº ÏïîÌò∏Ìôî
            if 'content' in vo_dict:
                update_fields.append("DIARY_CONTENT = fn_enc(:content, :encryption_key)")
                params["content"] = vo_dict['content']  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
            
            # AI ÏùëÎãµ ÏàòÏ†ï Ïãú Îã®Ïùº ÏïîÌò∏Ìôî
            if 'ai_response' in vo_dict:
                update_fields.append("AI_RESPONSE = fn_enc(:ai_response, :encryption_key)")
                params["ai_response"] = vo_dict['ai_response']  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
            
            # üî• ÏàòÏ†ï 2: ÏùëÎãµÍ∞í Îß§Ìïë Ï≤òÎ¶¨ (ÏàúÏÑú Ï§ëÏöî!)
            # condition1~3_responseÎäî Î®ºÏ†Ä Ï≤òÎ¶¨
            for i in range(1, 4):
                response_field = f'condition{i}_response'
                if response_field in vo_dict:
                    update_fields.append(f"CONDITION{i}_RESPONSE = fn_enc(:{response_field}, :encryption_key)")
                    params[response_field] = vo_dict[response_field]  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
            
            # condition4_response -> AI_SELECT Îß§Ìïë
            if 'condition4_response' in vo_dict:
                update_fields.append("AI_SELECT = :ai_select")
                params["ai_select"] = vo_dict['condition4_response']
            
            # condition5_response -> CONDITION4_RESPONSE Îß§Ìïë
            if 'condition5_response' in vo_dict:
                update_fields.append("CONDITION4_RESPONSE = fn_enc(:condition4_response_mapped, :encryption_key)")
                params["condition4_response_mapped"] = vo_dict['condition5_response']  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
            
            # condition6_response -> CONDITION5_RESPONSE Îß§Ìïë
            if 'condition6_response' in vo_dict:
                update_fields.append("CONDITION5_RESPONSE = fn_enc(:condition5_response_mapped, :encryption_key)")
                params["condition5_response_mapped"] = vo_dict['condition6_response']  # ÏõêÎ≥∏ ÌÖçÏä§Ìä∏
            
            # üî• ÏàòÏ†ï 3: Ï°∞Í±¥Îì§ÏùÄ ÏïîÌò∏ÌôîÌïòÏßÄ ÏïäÏùå
            for i in range(1, 7):
                condition_field = f'condition{i}'
                if condition_field in vo_dict:
                    update_fields.append(f"CONDITION{i} = :{condition_field}")
                    params[condition_field] = vo_dict[condition_field]
            
            # Í∏∞ÌÉÄ ÌïÑÎìúÎì§
            if 'ai_model' in vo_dict:
                update_fields.append("AI_MODEL = :ai_model")
                params["ai_model"] = vo_dict['ai_model']
            
            if 'record_date' in vo_dict:
                update_fields.append("RECORD_DATE = :record_date")
                params["record_date"] = vo_dict['record_date']
            
            # üî• ÏàòÏ†ï 4: ÏóÖÎç∞Ïù¥Ìä∏Ìï† ÌïÑÎìúÍ∞Ä ÏóÜÏúºÎ©¥ ÏÑ±Í≥µÏúºÎ°ú Ï≤òÎ¶¨
            if not update_fields:
                print(f"‚úÖ ÏàòÏ†ïÌï† ÌïÑÎìúÍ∞Ä ÏóÜÏùå (ID: {diary_idx})")
                return True
            
            # UPDATE_DATEÎäî Ìï≠ÏÉÅ Ï∂îÍ∞Ä
            update_fields.append("UPDATE_DATE = NOW()")
            
            # üî• ÏàòÏ†ï 5: SQL ÏøºÎ¶¨ Ï†ïÎ¶¨
            sql = text(f"""
                UPDATE tbl_emotion_diary 
                SET {', '.join(update_fields)}
                WHERE DIARY_IDX = :diary_idx AND STATUS_CODE = 'Y'
            """)
            
            print(f"üîç Ïã§ÌñâÌï† SQL: {sql}")
            print(f"üîç ÌååÎùºÎØ∏ÌÑ∞: {params}")
            
            result = self.db.execute(sql, params)
            self.db.commit()
            
            print(f"‚úÖ ÏïîÌò∏ÌôîÎêú Í∞êÏ†ïÏùºÍ∏∞ ÏàòÏ†ï ÏôÑÎ£å (ID: {diary_idx}, ÏòÅÌñ•Î∞õÏùÄ Ìñâ: {result.rowcount})")
            return result.rowcount > 0
            
        except Exception as e:
            print(f"‚ùå ÏïîÌò∏ÌôîÎêú Í∞êÏ†ïÏùºÍ∏∞ ÏàòÏ†ï Ï§ë Ïò§Î•ò: {str(e)}")
            print(f"‚ùå vo_dict: {vo.dict() if vo else 'None'}")
            traceback.print_exc()
            self.db.rollback()
            raise
    
    def delete(self, diary_idx: int) -> bool:
        """Í∞êÏ†ïÏùºÍ∏∞ ÏÇ≠Ï†ú (ÎÖºÎ¶¨ÏÇ≠Ï†ú)"""
        try:
            sql = text("""
                UPDATE tbl_emotion_diary 
                SET STATUS_CODE = 'N', UPDATE_DATE = NOW()
                WHERE DIARY_IDX = :diary_idx AND STATUS_CODE = 'Y'
            """)
            
            result = self.db.execute(sql, {"diary_idx": diary_idx})
            self.db.commit()
            
            print(f"‚úÖ Í∞êÏ†ïÏùºÍ∏∞ ÏÇ≠Ï†ú ÏôÑÎ£å (ID: {diary_idx})")
            return result.rowcount > 0
            
        except Exception as e:
            print(f"‚ùå Í∞êÏ†ïÏùºÍ∏∞ ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò: {str(e)}")
            traceback.print_exc()
            self.db.rollback()
            raise
